= Multiple Pointers Examples

Some examples that make use of the “multiple pointers pattern” or “multiple pointers approach.”

== sumToZero(xs)

Write a function which accepts a sorted array of integers and returns the first pair where the sum is 0.
Return the pair in an array (like a tuple) or `undefined` if such a pair is not found.

=== Unit Tests

[source,typescript,lineos]
----
include::example$src/05-problem-solving-patterns/sumToZero.test.ts[]
----

=== v1 nested loops

This is a naive solution where we perform a loop inside a loop, therefore stem:[O(n^2)].
Start at the first element and check with every remaining elements.
Then, start with the second element and again check with every remaining elements. And so on and so forth.

*TIME COMPLEXITY*: stem:[O(n²)] because we have a nested loop.

*SPACE COMPLEXITY*: stem:[O(1)] because we don't use extra space besides
the `i` and `j` variables.

[source,typescript,lineos]
----
include::example$src/05-problem-solving-patterns/sumToZero-v1.ts[]
----

=== v2 multiple pointers

This solution relies on the fact that the input array is sorted.
Using multiple pointers is more performant because it will do a single loop (stem:[O(n)]) instead of a two/nested loops (stem:[O(n^2)]).

*TIME COMPLEXITY*: stem:[O(n)] because we iterate over the array a single time.

*SPACE COMPLEXITY*: stem:[O(1)] because we don't use extra space besides the `i`, `j` and `sum` variables.

[source,ts,lineos]
----
include::example$src/05-problem-solving-patterns/sumToZero-v2.ts[]
----

<1> Handles the case where the logic inadvertently compares the sum of `0 + 0 === 0`.
It could happen if no other pair matches a sum of 0 but we have a 0 in the array, and the indexes in loop are the same for the left and right pointers.
+
So, if for example we have the list `[-1, 0, 2]`, and `l = 1` and `r = 1`, then `ints[l] + ints[r] === 0`, and we would INCORRECTLY return a pair of `[0, 0]`.
+
We may have a pair `[0, 0]` if our input array actually contains two zeroes.
For example, `[-1, 0, 0, 2, 3]`, then we would find a pair `[0, 0]` which when summed is zero, and it would be correct.

<2> Return the pair here if found.
Also note that there is an implicit `return undefined` at the end of the function in case it doesn't return because of some other condition.

Do note the `else if` and `else` conditions.
If we get a sum less then 0, we increment the left pointer, and if the sum is greater than 0, then we decrement the right pointer.
That is the clever part of this solution which enables it to loop only once (linear time complexity).

== Count Unique Values

Implement a function called `countUniqVals`, which accepts a sorted array of integers and counts the unique values in the array.

=== Unit Tests

[source,typescript,lineos]
----
include::example$src/05-problem-solving-patterns/countUniqVals.test.ts[]
----

=== v1 loop with single explicit pointer

*TIME COMPLEXITY*: stem:[O(n)].
We have to iterate once through the entire input.

*SPACE COMPLEXITY*: stem:[O(1)].
We do not create a new array that grows as the input grows.
Just a few control variables are necessary.

[source,typescript,lineos]
----
include::example$src/05-problem-solving-patterns/countUniqVals-v1.ts[]
----

<1> This solutions uses only one pointer `i` explicitly.
The other pointer is computed from the pointer `i`.
Since the array of numbers is sorted, we know for sure that if `[i] !== [i + 1]` then we have a new different value, and that equal values are always siblings (given the fact that the input is sorted).

<2> Also, this solution compares `[i]` with undefined if the input contains only a single number because then `[i + 1]` will be undefined.

We could return 1 if `nums.length` was 1, so we would only enter the loop in case we are sure to have at least two values in the array and that comparison with `undefined` would not happen.

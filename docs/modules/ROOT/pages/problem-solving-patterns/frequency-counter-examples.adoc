= Frequency Counter Examples

Some examples that make use of the “frequency counter pattern” or “frequency counter approach”.

== same()

Write a function called `same`, which accepts two arrays.
It should return true if every value in the array has it's corresponding value
squared in the second array.
The frequency of values must be the same.
The order doesn't matter.

.Unit Tests
[source,ts]
----
include::example$src/05-problem-solving-patterns/same.test.ts[]
----

=== v1

**TIME COMPLEXITY**: `O(n²)`.
We have only one explicit `for` loop, but `indexOf()` is also a loop which can potentially go over the entire array.
We actually have nested loops in this implementation.

**SPACE COMPLEXITY**: `O(1)`.
We just store the found index each time.
When we `ys.splice()` we are not creating further arrays.
Just reusing the same `ys` from the input, but making it smaller each time.
We can sure assume it is constant space.

[source,typescript]
----
include::example$src/05-problem-solving-patterns/same-v1.ts[]
----

This solution involves looping while we have matching elements in `xs`.
If we reach the end of the loop without getting an index of -1 it means every element in `xs` has a matching squared element in `ys`.

<1> We remove that element from `ys` so that one occurrence doesn't
ever match again. Important because we want to match the frequencies
of squares of values in `xs` in `ys`.

=== v2

This solution first counts the frequencies individually and then compare those frequencies.

1. Generate the frequencies of elements for both input arrays:

----
arr1 = [1, 2, 3, 1, 1, 3, 3, 3]
freq1 = { 1: 3, 2: 1, 3: 4}

arr2 = [1, 4, 9, 1, 1, 9, 9, 9]
freq2 = [1: 3, 4: 1, 9: 4]
----

Note that:

* stem:[1 ^ 2] is stem:[2]
* stem:[2 ^ 2] is stem:[4]
* stem:[3 ^ 2] is stem:[9]

Then we loop and check if the squared keys in `freq1` exist and have the same value in `freq2`.
As soon as something doesn't match, we return `false` to indicate the two arrays do not meet our criteria; else return `true`.

**TIME COMPLEXITY**: stem:[O(n)].
Three non-nested loops is still linear time.
Much better than two nested loops.

**SPACE COMPLEXITY**: stem:[O(n)].
We create two other objects with potentially the same number of keys as `xs` and `ys`.
So, the space taken inside the function is directly proportional to the input arrays size.

[source,ts]
----
include::example$src/05-problem-solving-patterns/same-v2.ts[]
----

Three loops is much better than a loop inside a loop.

* Two nested loops: stem:[O(n ^ 2)] — quadratic.
* Three loops one after the other: stem:[O(n)].

Three loops is actually stem:[O(3n)] but is simplified to stem:[O(n)].
It is still linear time.

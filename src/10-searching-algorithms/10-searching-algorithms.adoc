== 10 Searching Algorithms
:toc: left
:page-tags: algorithm data-structure search

Some languages have things like `indexOf()` or `find()`.
But let's create our own search functions.

What is a search algorithm‽

Linear search on arrays.

Binary Search on sorted arrays.

Naive string searching algorithm.

KMP string searching algorithm.

[data-tags="linear-search"]
=== Linear Search

The naive approach is to look at the elements one by one until the value sought for is found or until the end of the array is reached.

For sorted arrays, looking from first to last element (one by one) is not a good performant way of going about it.

ECMAScript already provides linear search:

* `indexOf()`
* `includes()`
* `find()`
* `findIndex()`

Those are not optimized with some more performant search algorithm because the JavaScript engine would not know if the input array was sorted or not or because they need to return an index, which require counting each element already inspected.

[NOTE]
====
Linear search *IS NOT* bad.
It is not performant as some other searching algorithms, but sometimes it is the only algorithm that makes sense in a given situation.
====

[data-tags="search linear array index"]
==== search(arr, val)

* Create a function that accepts an array of numbers and a numeric value.
* Loop through the array from beginning to end comparing each element with the search value.
* If the current element matches the value:
** Return the index at which it was found.
* Return -1 to indicate the value was not found in the array.

==== Unit Tests

[source,typescript,linenums]
----
include::./linear-search-num/searchNum.test.ts[]
----

==== v1 using simple for loop

[source,typescript,linenums]
----
include::./linear-search-num/searchNum-v1.ts[lines=5..-1]
----

A `forEach()` cannot be stopped.
It iterates over each element, from beginning to end, and this algorithm is optimized at least in the sense that it stops as soon the element is found (if found it is).
`reduce()` cannot be stopped either.
A good old _for loop_ is OK for situations like this.

Linear search will seldom be stem:[O(1)].
That is very rare indeed
Most likely, an element is found at stem:[1/3] of the way, or stem:[3/4] of
the way, that is, _late_ or not at all, which means it is
stem:[O(n)].
Remember that for Big O we care about the general trend.
As the search could go until the end of the array, we say linear search is
stem:[O(n)].

=== Binary Search

Much faster than linear search, but arrays have to be sorted.
At each iteration, half of the array can be “eliminated”.

The idea is that an element in the middle is picked and then a comparison is performed to see if it is “less than or grater than” the element being sought for.
If greater than, discard the half that contains the less than elements.
If less than, discard the half that contains the greater than elements.
I each case, keep repeating a similar process with the half that could still potentially contain the element being searched for.

This idea is also known as _divide and conquer_.

[WARNING]
====
For binary search to work, the array has to be *sorted*.
====

.example rationale
----
Find 8

                     target element
                            \
                             \
                              v
  1   2   3   4   5   6   7   8   9   10   11
                      ^
                     /
                    /
            middle element
            8 > 6, discard left half
            keep searching right half


                              v
                          7   8   9   10   11
                                  ^
                                 /
                                /
                        middle element
                        8 < 9, discard right half
                        keep searching left half


                              v
                          7   8
                              ^
                             /
                            /
                       round up or down to pick middle element
                       let's round up
                       8 is neither < 8 nor > 8
                       found it
----
